# 정렬 알고리즘에 대한 메모입니다

## 선택 정렬

<p>제일 왼쪽에 있는 수를 아직 처리되지 않은 수들 중 가장 작은 수와 바꾼다는 개념 </p>
<br />
<p>시간 복잡도는 N + (N - 1) + (N - 2) + ... + 2 이므로 빅오 표기법에 따라서 O(N^2)라고 작성한다</p>

## 삽입 정렬

<p>자신과 자신 왼쪽의 수를 비교해서 왼쪽의 수보다 앞에 있어야 하는지 뒤에 있어야 하는지를 판단한다</p>
<br />

<p>시간 복잡도는 O(N^2)이고 이중 반복문을 사용하기 때문 (\*모든 이중 반복문이 O(N^2)인 것은 아님)</p>
<p>최선의 경우에 O(N)의 시간 복잡도를 가질 수 있다.</p>

## 퀵 정렬

<p>피벗을 기준으로 왼쪽에서는 피벗보다 작은 값, 오른쪽에서는 피벗보다 큰 값을 찾은 다음,<br/> 두 값의 위치를 바꿔주고 만약 두 값이 교차된다면 피벗과 작은 값의 위치를 바꿔서 분할을 수행한다<br />분할을 수행한 뒤에 나누어진 두 영역에 대해서 다시 퀵 정렬을 수행한다</p>

<p>피벗은 첫 값을 기준으로 한다</p>
<p>리스트 슬라이싱과 리스트 컴프레션을 이용해서 짧은 코드로 간결하게 작성할 수 있다</p>

<p>평균적으로 O(NlogN)의 시간 복잡도를 가지지만 최악의 경우 O(N^2)의 시간 복잡도를 가집니다</p>

## 계수 정렬

<p>각각의 데이터가 몇 번씩 등장하는지 세는 방식으로 동작하는 알고리즘이다<br />상대적으로 공간 복잡도가 높지만 조건만 만족하면 퀵 정렬보다 빠르게 동작한다는 점이 특징이다</p>
<p>시간 복잡도와 공간 복잡도는 모두 O(N + K)입니다<br />때에 따라서 심각한 비효율성을 초래할 수 있습니다</p>